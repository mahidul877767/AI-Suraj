<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FINAL Particle Reactor // AR Mode</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        
        /* 1. VIDEO LAYER (BACKGROUND) */
        #video-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0; /* Behind everything */
            overflow: hidden;
        }
        video {
            width: 100%; height: 100%; object-fit: cover;
            transform: scaleX(-1); /* Mirror effect */
            /* Add some visual style to the camera feed */
            filter: brightness(0.6) contrast(1.2) hue-rotate(180deg); 
        }

        /* 2. PARTICLE LAYER (FOREGROUND) */
        canvas { 
            position: absolute; top: 0; left: 0; 
            z-index: 10; /* On top of video */
            display: block; 
        }

        /* 3. UI LAYER */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }
        
        #hud-top {
            position: absolute; top: 20px; right: 20px; text-align: right;
        }
        /* Increased font size for dramatic effect */
        .mode-label { font-size: 3rem; font-weight: 900; letter-spacing: 3px; }
        .sub-text { font-size: 1rem; color: #ccc; margin-top: 5px; }

        #controls {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px; border-radius: 8px; border-left: 3px solid #00ffff;
            color: #fff; font-size: 1rem; line-height: 1.6;
        }
        b { color: #00ffff; }

        /* Startup Screen */
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; align-items: center; justify-content: center;
            flex-direction: column; color: #00ffff;
        }
        .error-message { color: red !important; text-shadow: 0 0 10px red; }
    </style>
</head>
<body>

    <div id="loading-screen">
        <h1>INITIALIZING SYSTEMS...</h1>
        <p id="status-text">Requesting Camera Access...</p>
        <p style="color: #666; font-size: 0.8rem; margin-top:20px;">(REMINDER: Must be run on a Local Server/Live Server)</p>
    </div>

    <div id="video-container">
        <video id="input-video" playsinline></video>
    </div>

    <div id="ui-layer">
        <div id="controls">
            <div>‚úä <b>FIST:</b> Black Hole (Attract)</div>
            <div>üñê <b>PALM:</b> Shockwave (Repel)</div>
            <div>‚òùÔ∏è <b>1 FINGER:</b> Sphere</div>
            <div>‚úåÔ∏è <b>2 FINGERS:</b> Torus</div>
            <div>ü§ü <b>3 FINGERS:</b> Cube</div>
            <div>üññ <b>4 FINGERS:</b> Vortex</div>
        </div>

        <div id="hud-top">
            <div class="mode-label" id="mode-display">SCANNING</div>
            <div class="sub-text">ACTIVE AR HUD // HAND TRACKING</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // --- 0. ERROR CHECK & ELEMENTS ---
        const statusText = document.getElementById('status-text');
        const loadingScreen = document.getElementById('loading-screen');

        if (location.protocol === 'file:') {
            statusText.innerHTML = "‚ùå **CAMERA BLOCKED!** Please run this using a **Local Server** (like Live Server or Python http.server).";
            statusText.classList.add('error-message');
            loadingScreen.style.backgroundColor = 'rgba(50, 0, 0, 0.9)';
            throw new Error("Local Server Required for Camera Access");
        }

        // --- 1. CONFIG ---
        const PARTICLE_COUNT = 5000;
        const PARTICLE_SIZE = 1.8;

        // --- 2. SETUP THREE.JS (TRANSPARENT) ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 60;

        // Alpha: true is crucial for showing the video background
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // BLOOM Setup
        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight), 
            1.5, 0.4, 0.85
        );
        bloomPass.threshold = 0;
        bloomPass.strength = 1.8; 
        bloomPass.radius = 0.5;

        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 3. PARTICLES & BASE SHAPES ---
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        // Storage for target coordinates
        const basePos = { sphere: [], cube: [], torus: [], vortex: [] };
        const colorObj = new THREE.Color();

        // Create Particle Texture (Soft Glow)
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        context.fillStyle = gradient;
        context.fillRect(0,0,32,32);
        const particleTexture = new THREE.CanvasTexture(canvas);

        // Generate particle positions and target shapes
        for(let i=0; i<PARTICLE_COUNT; i++) {
            // Initial Random Position
            positions.push((Math.random()-0.5)*150, (Math.random()-0.5)*100, (Math.random()-0.5)*50);
            colors.push(1,1,1);
            
            // Sphere (Fibonacci sphere distribution)
            const phi = Math.acos(1 - 2 * i / PARTICLE_COUNT);
            const theta = Math.PI * (1 + Math.sqrt(5)) * i;
            const r = 25;
            basePos.sphere.push(r*Math.cos(theta)*Math.sin(phi), r*Math.sin(theta)*Math.sin(phi), r*Math.cos(phi));

            // Cube
            const s = 35;
            basePos.cube.push((Math.random()-0.5)*s, (Math.random()-0.5)*s, (Math.random()-0.5)*s);

            // Torus
            const u = Math.random()*Math.PI*2, v = Math.random()*Math.PI*2;
            const R=25, t=8;
            basePos.torus.push((R+t*Math.cos(v))*Math.cos(u), (R+t*Math.cos(v))*Math.sin(u), t*Math.sin(v));
            
            // Vortex (Spiral)
            const ang = i * 0.1;
            const dst = Math.sqrt(i)*0.8;
            basePos.vortex.push(Math.cos(ang)*dst, Math.sin(ang)*dst, (Math.random()-0.5)*5);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE, vertexColors: true, map: particleTexture,
            blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 4. ANIMATION & PHYSICS LOOP ---
        const state = { detected: false, mode: 'IDLE', handPos: new THREE.Vector3(0,0,0), time: 0 };
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            state.time += dt;
            
            const posAttr = geometry.attributes.position;
            const colAttr = geometry.attributes.color;
            const modeLabel = document.getElementById('mode-display');
            
            // UI Update
            if(state.detected) {
                modeLabel.innerText = state.mode;
                modeLabel.style.color = "#00ffff";
            } else {
                modeLabel.innerText = "SCANNING";
                modeLabel.style.color = "#ff3333";
            }

            const hx = state.handPos.x;
            const hy = state.handPos.y;

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const ix = i*3, iy = i*3+1, iz = i*3+2;
                let tx, ty, tz;
                let ease = 0.05; // Base smoothing speed

                // --- MODE LOGIC ---
                if (!state.detected) {
                    // IDLE: Subtle slow movement
                    tx = posAttr.array[ix] + Math.sin(state.time * 0.2 + i * 0.01) * 0.2;
                    ty = posAttr.array[iy] + Math.cos(state.time * 0.3 + i * 0.01) * 0.2;
                    tz = posAttr.array[iz];
                    colorObj.setHSL(0.6, 0.5, 0.5); // Blue-ish
                    ease = 0.01;
                }
                else if (state.mode === 'BLACKHOLE') {
                    // Attract to hand
                    tx = hx; ty = hy; tz = 0;
                    ease = 0.15; colorObj.setHex(0xff3300); // Red
                }
                else if (state.mode === 'SHOCKWAVE') {
                    // Repel from hand
                    const dx = posAttr.array[ix] - hx, dy = posAttr.array[iy] - hy;
                    const d = Math.sqrt(dx*dx + dy*dy) + 0.01;
                    const f = Math.max(0, (60-d)*2); // Repulsion force
                    tx = posAttr.array[ix] + (dx/d)*f; 
                    ty = posAttr.array[iy] + (dy/d)*f; 
                    tz = posAttr.array[iz];
                    ease = 0.2; colorObj.setHex(0x00ffff); // Cyan
                }
                else if (state.mode === 'CHAOS') {
                    // Random Explosion
                    tx = posAttr.array[ix] + (Math.random()-0.5) * 20;
                    ty = posAttr.array[iy] + (Math.random()-0.5) * 20;
                    tz = posAttr.array[iz] + (Math.random()-0.5) * 20;
                    ease = 0.2; colorObj.setHSL(Math.random(), 1, 0.7); // Rainbow
                }
                else {
                    // FORMATIONS (Shapes)
                    let bx, by, bz;
                    if(state.mode === 'CUBE') { 
                        bx=basePos.cube[ix]; by=basePos.cube[iy]; bz=basePos.cube[iz]; colorObj.setHex(0x00ff00); // Green
                    }
                    else if(state.mode === 'TORUS') { 
                        bx=basePos.torus[ix]; by=basePos.torus[iy]; bz=basePos.torus[iz]; colorObj.setHex(0xaa00ff); // Purple
                    }
                    else if(state.mode === 'VORTEX') { 
                        bx=basePos.vortex[ix]; by=basePos.vortex[iy]; bz=basePos.vortex[iz]; colorObj.setHex(0xffaa00); // Gold
                        const s = state.time*3;
                        const rx = bx*Math.cos(s) - by*Math.sin(s);
                        const ry = bx*Math.sin(s) + by*Math.cos(s);
                        bx=rx; by=ry;
                    }
                    else { // SPHERE (Default 1 finger)
                        bx=basePos.sphere[ix]; by=basePos.sphere[iy]; bz=basePos.sphere[iz]; colorObj.setHSL((state.time*0.1)%1, 0.8, 0.5); // Rotating Blue Hue
                    }

                    // Shape Rotation
                    if(state.mode !== 'VORTEX') {
                        const s = state.time * 0.5;
                        const rx = bx*Math.cos(s) - bz*Math.sin(s);
                        const rz = bx*Math.cos(s) + bx*Math.sin(s);
                        bx=rx; bz=rz;
                    }

                    // Shift shape to hand position
                    tx = bx + hx; ty = by + hy; tz = bz;
                }

                // Apply Movement (Lerp)
                posAttr.array[ix] += (tx - posAttr.array[ix]) * ease;
                posAttr.array[iy] += (ty - posAttr.array[iy]) * ease;
                posAttr.array[iz] += (tz - posAttr.array[iz]) * ease;

                // Apply Color
                colAttr.array[ix] = colorObj.r; 
                colAttr.array[iy] = colorObj.g; 
                colAttr.array[iz] = colorObj.b;
            }

            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;
            composer.render();
        }

        // --- 5. MEDIA PIPE HAND TRACKING ---
        function onResults(results) {
            loadingScreen.style.display = 'none';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.detected = true;
                const lm = results.multiHandLandmarks[0];

                // Map hand position to 3D space
                const x = (0.5 - lm[9].x) * 150; 
                const y = (0.5 - lm[9].y) * 100;
                state.handPos.lerp(new THREE.Vector3(x, y, 0), 0.2);

                // Simple Finger Counting
                const isUp = (t, b) => lm[t].y < lm[b].y;
                let f = 0;
                if(isUp(8,6)) f++; // Index
                if(isUp(12,10)) f++; // Middle
                if(isUp(16,14)) f++; // Ring
                if(isUp(20,18)) f++; // Pinky
                if(Math.abs(lm[4].x - lm[2].x) > 0.05) f++; // Thumb (X-axis check)

                // Gesture Logic
                const rockSign = isUp(8,6) && isUp(20,18) && !isUp(12,10) && !isUp(16,14);

                if(rockSign) state.mode = 'CHAOS'; 
                else if(f===0) state.mode = 'BLACKHOLE';
                else if(f===5) state.mode = 'SHOCKWAVE';
                else if(f===2) state.mode = 'TORUS';
                else if(f===3) state.mode = 'CUBE';
                else if(f===4) state.mode = 'VORTEX';
                else state.mode = 'SPHERE';
            } else {
                state.detected = false;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);

        const video = document.getElementById('input-video');
        const cam = new Camera(video, {
            onFrame: async () => { await hands.send({image: video}); },
            width: 640, height: 480
        });
        
        cam.start()
        .then(() => { statusText.innerText = "System Active. Please show your hand."; })
        .catch(err => {
            statusText.innerHTML = "‚ùå **CAMERA ACCESS FAILED!** Check permissions or console.";
            statusText.classList.add('error-message');
            console.error("Camera start error:", err);
        });

        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
    </html>
